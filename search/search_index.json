{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python tunnel This Python package provides a convenient wrapper for running tunnel commands. Documentation Documentation are located here Usage This is not a module, instead, you can just download tunnel.py and import it you need atleast python 3.8 from tunnel import Tunnel # Setting up the tunnel tunnel = Tunnel(3000) # Tunnel on port 3000 tunnel.add_tunnel( command=\"cloudflared tunnel --url http://localhost:{port}\", # {port} automatically changed to 3000 pattern=r\"[\\w-]+\\.trycloudflare\\.com\", name=\"Cloudflare\" ) # Starting the tunnel tunnel.start() # Stopping the tunnel tunnel.stop() # Using a with block with tunnel: pass # Setting up tunnel with a list tunnel_list = [ { \"command\": \"tunnel_1_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_1\" }, { \"command\": \"tunnel_2_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_2\" } ] tunnel = Tunnel.with_tunnel_list(3000, tunnel_list) tunnel.start() Logger Propagate by default propagate is False when initializing Tunnel meaning the logger for Tunnel is detached from root logger you can set to True to propagate log message to root logger, to use root logger message format, etc tunnel = Tunnel(3000, propagate=True) Logger Handler set your logger.Handler when initializing Tunnel import logging handler = logging.FileHandler(\"tunnel.log\", encoding=\"utf-8\") handler.setFormatter(logging.Formatter(\"{asctime}: {message}\", datefmt=\"%X\", style=\"{\")) tunnel = Tunnel(3000, log_handlers=[handler]) Callback since version 0.1.0 Tunnel now has 2 callback set it up when initializing Tunnel or when adding tunnel Tunnel.add_tunnel example def print_callback(urls: list[tuple[str, str | None, str | None]]) -> None: print(urls) def regex_callback(url: str, note: str | None, name: str | None) -> None: print(url, note, name) tunnel = Tunnel(3000, callback=print_callback) tunnel.add_tunnel(command=..., pattern=..., name=..., callback=regex_callback) with tunnel: # code goes here in code above, difference between print_callback and regex_callback is print_callback executed after all the URLs is printed. will retrive a list of tuple(url, note, name) regex_callback executed after regex pattern is matched to URL (before print happen). will retrive url: str , note: str | None and name: str | None example usage is to set callback to send the urls using discord webhook maybe ? TODO [ ] fixing stuff, adding stuff idk Personal Note well, in 23 Feb 2024, i accidentaly force push to the repo which overwrite the date of the commit but the project still work, so whatever for the future me, DO NOT USE git push -f for whatever reason Licensed under the terms of the MIT License. See the LICENSE file for details.","title":"README"},{"location":"#python-tunnel","text":"This Python package provides a convenient wrapper for running tunnel commands.","title":"python tunnel"},{"location":"#documentation","text":"Documentation are located here","title":"Documentation"},{"location":"#usage","text":"This is not a module, instead, you can just download tunnel.py and import it you need atleast python 3.8 from tunnel import Tunnel # Setting up the tunnel tunnel = Tunnel(3000) # Tunnel on port 3000 tunnel.add_tunnel( command=\"cloudflared tunnel --url http://localhost:{port}\", # {port} automatically changed to 3000 pattern=r\"[\\w-]+\\.trycloudflare\\.com\", name=\"Cloudflare\" ) # Starting the tunnel tunnel.start() # Stopping the tunnel tunnel.stop() # Using a with block with tunnel: pass # Setting up tunnel with a list tunnel_list = [ { \"command\": \"tunnel_1_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_1\" }, { \"command\": \"tunnel_2_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_2\" } ] tunnel = Tunnel.with_tunnel_list(3000, tunnel_list) tunnel.start()","title":"Usage"},{"location":"#logger-propagate","text":"by default propagate is False when initializing Tunnel meaning the logger for Tunnel is detached from root logger you can set to True to propagate log message to root logger, to use root logger message format, etc tunnel = Tunnel(3000, propagate=True)","title":"Logger Propagate"},{"location":"#logger-handler","text":"set your logger.Handler when initializing Tunnel import logging handler = logging.FileHandler(\"tunnel.log\", encoding=\"utf-8\") handler.setFormatter(logging.Formatter(\"{asctime}: {message}\", datefmt=\"%X\", style=\"{\")) tunnel = Tunnel(3000, log_handlers=[handler])","title":"Logger Handler"},{"location":"#callback","text":"since version 0.1.0 Tunnel now has 2 callback set it up when initializing Tunnel or when adding tunnel Tunnel.add_tunnel example def print_callback(urls: list[tuple[str, str | None, str | None]]) -> None: print(urls) def regex_callback(url: str, note: str | None, name: str | None) -> None: print(url, note, name) tunnel = Tunnel(3000, callback=print_callback) tunnel.add_tunnel(command=..., pattern=..., name=..., callback=regex_callback) with tunnel: # code goes here in code above, difference between print_callback and regex_callback is print_callback executed after all the URLs is printed. will retrive a list of tuple(url, note, name) regex_callback executed after regex pattern is matched to URL (before print happen). will retrive url: str , note: str | None and name: str | None example usage is to set callback to send the urls using discord webhook maybe ?","title":"Callback"},{"location":"#todo","text":"[ ] fixing stuff, adding stuff idk","title":"TODO"},{"location":"#personal-note","text":"well, in 23 Feb 2024, i accidentaly force push to the repo which overwrite the date of the commit but the project still work, so whatever for the future me, DO NOT USE git push -f for whatever reason Licensed under the terms of the MIT License. See the LICENSE file for details.","title":"Personal Note"},{"location":"reference/SUMMARY/","text":"tunnel","title":"SUMMARY"},{"location":"reference/tunnel/","text":"Tunnel Tunnel ( port , check_local_port = True , debug = False , timeout = 60 , propagate = False , log_handlers = None , log_dir = None , callback = None , ) Tunnel class for managing subprocess-based tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. propagate ( bool , default: False ) \u2013 Flag to propagate log messages to the root logger, if False will create custom log format to print log. log_handlers ( List [ Handler ] , default: None ) \u2013 List of logging handlers to be added to the Tunnel logger. log_dir ( StrOrPath , default: None ) \u2013 Directory to store tunnel log files. If None it will set to os.get_cwd() . callback ( Callable [[ List [ Tuple [ str , Optional [ str ]]]], None] , default: None ) \u2013 A callback function to be called when Tunnel URL is printed. will call callback([(url1, note1), (url2, note2), ...]) -> None . Note output of each tunnel command will be saved to log_dir with_tunnel_list classmethod with_tunnel_list ( port , tunnel_list , check_local_port = True , debug = False , timeout = 60 , propagate = False , log_handlers = None , log_dir = None , callback = None , ) Create a Tunnel instance with a pre-defined list of tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. tunnel_list ( List [ dict ] ) \u2013 List of dictionaries specifying tunnel configurations. Each dictionary must have the keys command , pattern , name , note (optional), and callback (optional). check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. propagate ( bool , default: False ) \u2013 Flag to propagate log messages to the root logger, if False will create custom log format to print log. log_handlers ( List [ Handler ] , default: None ) \u2013 List of logging handlers to be added to the Tunnel logger. log_dir ( StrOrPath , default: None ) \u2013 Directory to store tunnel log files. If None it will set to os.get_cwd() . callback ( Callable [[ List [ Tuple [ str , Optional [ str ], Optional [ str ]]]], None] , default: None ) \u2013 A callback function to be called when Tunnel URL is printed. will call callback([(url1, note1, name1), (url2, note2, name2), ...]) -> None . Raises: ValueError \u2013 Raised if tunnel_list doesn't have dict with keys atleast command , pattern , name Note output of each tunnel command will be saved to log_dir add_tunnel add_tunnel ( * , command , pattern , name , note = None , callback = None ) Add a tunnel. Parameters: command ( str ) \u2013 The command to execute for the tunnel. pattern ( StrOrRegexPattern ) \u2013 A regular expression pattern to match the tunnel URL. name ( str ) \u2013 The name of the tunnel. note ( str , default: None ) \u2013 A note about the tunnel. Defaults to None . callback ( Callable [[ str , Optional [ str ], Optional [ str ]], None] , default: None ) \u2013 A callback function to be called when when the regex pattern matched. will call callback(url, note, name) -> None . Defaults to None . Note name must be unique name as is being used for .log file, start start () Start the tunnel and wait for the URLs to be printed. Raises: RuntimeError \u2013 Raised if tunnel is already running stop stop () Stop the tunnel and reset internal state. Raises: RuntimeError \u2013 Raised if tunnel is not running reset reset () Reset internal state. is_port_in_use staticmethod is_port_in_use ( port ) Check if the specified port is in use. Parameters: port ( int ) \u2013 The port to check. Returns: bool ( bool ) \u2013 True if the port is in use, False otherwise. wait_for_condition staticmethod wait_for_condition ( condition , * , interval = 1 , timeout = 10 ) Wait for the condition to be true until the specified timeout. Mostly for internal use but can be used for anything else. Parameters: condition ( Callable [[], bool ] ) \u2013 The condition to check. interval ( int , default: 1 ) \u2013 The interval (in seconds) between condition checks. timeout ( int , default: 10 ) \u2013 Maximum time to wait for the condition. None for no timeout. Returns: bool ( bool ) \u2013 True if the condition is met, False if timeout is reached.","title":"tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel","text":"Tunnel ( port , check_local_port = True , debug = False , timeout = 60 , propagate = False , log_handlers = None , log_dir = None , callback = None , ) Tunnel class for managing subprocess-based tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. propagate ( bool , default: False ) \u2013 Flag to propagate log messages to the root logger, if False will create custom log format to print log. log_handlers ( List [ Handler ] , default: None ) \u2013 List of logging handlers to be added to the Tunnel logger. log_dir ( StrOrPath , default: None ) \u2013 Directory to store tunnel log files. If None it will set to os.get_cwd() . callback ( Callable [[ List [ Tuple [ str , Optional [ str ]]]], None] , default: None ) \u2013 A callback function to be called when Tunnel URL is printed. will call callback([(url1, note1), (url2, note2), ...]) -> None . Note output of each tunnel command will be saved to log_dir","title":"Tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel.with_tunnel_list","text":"with_tunnel_list ( port , tunnel_list , check_local_port = True , debug = False , timeout = 60 , propagate = False , log_handlers = None , log_dir = None , callback = None , ) Create a Tunnel instance with a pre-defined list of tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. tunnel_list ( List [ dict ] ) \u2013 List of dictionaries specifying tunnel configurations. Each dictionary must have the keys command , pattern , name , note (optional), and callback (optional). check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. propagate ( bool , default: False ) \u2013 Flag to propagate log messages to the root logger, if False will create custom log format to print log. log_handlers ( List [ Handler ] , default: None ) \u2013 List of logging handlers to be added to the Tunnel logger. log_dir ( StrOrPath , default: None ) \u2013 Directory to store tunnel log files. If None it will set to os.get_cwd() . callback ( Callable [[ List [ Tuple [ str , Optional [ str ], Optional [ str ]]]], None] , default: None ) \u2013 A callback function to be called when Tunnel URL is printed. will call callback([(url1, note1, name1), (url2, note2, name2), ...]) -> None . Raises: ValueError \u2013 Raised if tunnel_list doesn't have dict with keys atleast command , pattern , name Note output of each tunnel command will be saved to log_dir","title":"with_tunnel_list"},{"location":"reference/tunnel/#tunnel.Tunnel.add_tunnel","text":"add_tunnel ( * , command , pattern , name , note = None , callback = None ) Add a tunnel. Parameters: command ( str ) \u2013 The command to execute for the tunnel. pattern ( StrOrRegexPattern ) \u2013 A regular expression pattern to match the tunnel URL. name ( str ) \u2013 The name of the tunnel. note ( str , default: None ) \u2013 A note about the tunnel. Defaults to None . callback ( Callable [[ str , Optional [ str ], Optional [ str ]], None] , default: None ) \u2013 A callback function to be called when when the regex pattern matched. will call callback(url, note, name) -> None . Defaults to None . Note name must be unique name as is being used for .log file,","title":"add_tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel.start","text":"start () Start the tunnel and wait for the URLs to be printed. Raises: RuntimeError \u2013 Raised if tunnel is already running","title":"start"},{"location":"reference/tunnel/#tunnel.Tunnel.stop","text":"stop () Stop the tunnel and reset internal state. Raises: RuntimeError \u2013 Raised if tunnel is not running","title":"stop"},{"location":"reference/tunnel/#tunnel.Tunnel.reset","text":"reset () Reset internal state.","title":"reset"},{"location":"reference/tunnel/#tunnel.Tunnel.is_port_in_use","text":"is_port_in_use ( port ) Check if the specified port is in use. Parameters: port ( int ) \u2013 The port to check. Returns: bool ( bool ) \u2013 True if the port is in use, False otherwise.","title":"is_port_in_use"},{"location":"reference/tunnel/#tunnel.Tunnel.wait_for_condition","text":"wait_for_condition ( condition , * , interval = 1 , timeout = 10 ) Wait for the condition to be true until the specified timeout. Mostly for internal use but can be used for anything else. Parameters: condition ( Callable [[], bool ] ) \u2013 The condition to check. interval ( int , default: 1 ) \u2013 The interval (in seconds) between condition checks. timeout ( int , default: 10 ) \u2013 Maximum time to wait for the condition. None for no timeout. Returns: bool ( bool ) \u2013 True if the condition is met, False if timeout is reached.","title":"wait_for_condition"}]}