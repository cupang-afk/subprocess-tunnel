{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python tunnel This Python package provides a convenient wrapper for running tunnel commands. Documentation Documentation are located here Usage This is not a module, instead, you can just download tunnel.py and import it from tunnel import Tunnel # Setting up the tunnel wrapper = Tunnel(3000) # Tunnel on port 3000 wrapper.add_tunnel( command=\"cloudflared tunnel --url http://localhost:{port}\", # {port} automatically changed to 3000 pattern=r\"[\\w-]+\\.trycloudflare\\.com\", name=\"Cloudflare\" ) # Starting the tunnel wrapper.start() # Stopping the tunnel wrapper.stop() # Using a with block with wrapper: pass # Setting up tunnel with a list tunnel_list = [ { \"command\": \"tunnel_1_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_1\" }, { \"command\": \"tunnel_2_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_2\" } ] wrapper = Tunnel.with_tunnel_list(3000, tunnel_list) wrapper.start() Logger Propagate by default propagate is False when initializing Tunnel meaning the logger for Tunnel is detached from root logger you can set to True to propagate log message to root logger, to use root logger message format, etc tunnel = Tunnel(3000, propagate=True) Callback since version 0.1.0 Tunnel now has 2 callback set it up when initializing Tunnel or when adding tunnel Tunnel.add_tunnel example def print_callback(urls: list[tuple[str, str | None]]) -> None: print(urls) def regex_callback(url: str, note: str | None) -> None: print(url, note) tunnel = Tunnel(3000, callback=print_callback) tunnel.add_tunnel(command=..., pattern=..., name=..., callback=regex_callback) with tunnel: # code goes here difference between print_callback and regex_callback is print_callback executed after all the URLs is printed. will retrive a list of tuple(url, note) regex_callback executed after regex pattern is matched to URL (before print happen). will retrive url: str and note: str | None example usage is to set callback to send the urls using discord webhook maybe ? TODO [ ] - Personal Note well, in 23 Feb 2024, i accidentaly force push to the repo which overwrite the date of the commit but the project still work, so whatever for the future me, DO NOT USE git push -f for whatever reason Licensed under the terms of the MIT License. See the LICENSE file for details.","title":"README"},{"location":"#python-tunnel","text":"This Python package provides a convenient wrapper for running tunnel commands.","title":"python tunnel"},{"location":"#documentation","text":"Documentation are located here","title":"Documentation"},{"location":"#usage","text":"This is not a module, instead, you can just download tunnel.py and import it from tunnel import Tunnel # Setting up the tunnel wrapper = Tunnel(3000) # Tunnel on port 3000 wrapper.add_tunnel( command=\"cloudflared tunnel --url http://localhost:{port}\", # {port} automatically changed to 3000 pattern=r\"[\\w-]+\\.trycloudflare\\.com\", name=\"Cloudflare\" ) # Starting the tunnel wrapper.start() # Stopping the tunnel wrapper.stop() # Using a with block with wrapper: pass # Setting up tunnel with a list tunnel_list = [ { \"command\": \"tunnel_1_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_1\" }, { \"command\": \"tunnel_2_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_2\" } ] wrapper = Tunnel.with_tunnel_list(3000, tunnel_list) wrapper.start()","title":"Usage"},{"location":"#logger-propagate","text":"by default propagate is False when initializing Tunnel meaning the logger for Tunnel is detached from root logger you can set to True to propagate log message to root logger, to use root logger message format, etc tunnel = Tunnel(3000, propagate=True)","title":"Logger Propagate"},{"location":"#callback","text":"since version 0.1.0 Tunnel now has 2 callback set it up when initializing Tunnel or when adding tunnel Tunnel.add_tunnel example def print_callback(urls: list[tuple[str, str | None]]) -> None: print(urls) def regex_callback(url: str, note: str | None) -> None: print(url, note) tunnel = Tunnel(3000, callback=print_callback) tunnel.add_tunnel(command=..., pattern=..., name=..., callback=regex_callback) with tunnel: # code goes here difference between print_callback and regex_callback is print_callback executed after all the URLs is printed. will retrive a list of tuple(url, note) regex_callback executed after regex pattern is matched to URL (before print happen). will retrive url: str and note: str | None example usage is to set callback to send the urls using discord webhook maybe ?","title":"Callback"},{"location":"#todo","text":"[ ] -","title":"TODO"},{"location":"#personal-note","text":"well, in 23 Feb 2024, i accidentaly force push to the repo which overwrite the date of the commit but the project still work, so whatever for the future me, DO NOT USE git push -f for whatever reason Licensed under the terms of the MIT License. See the LICENSE file for details.","title":"Personal Note"},{"location":"reference/SUMMARY/","text":"tunnel","title":"SUMMARY"},{"location":"reference/tunnel/","text":"Tunnel Tunnel class for managing subprocess-based tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. Default True. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. Default False. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. Default 60. propagate ( bool , default: False ) \u2013 Flag to propagate log messages to the root logger, if False will create custom log format to print log. Default False. log_dir ( os . PathLike , default: os . getcwd () ) \u2013 Directory to store log files. Default os.getcwd(). callback ( typing . Callable [[ list [ tuple [ str , str | None]]], None] , default: None ) \u2013 A callback function to be called when Tunnel URL is printed. callback([(url1, note1), (url2, note2), ...]) -> None with_tunnel_list classmethod with_tunnel_list ( port : int , tunnel_list : list [ tunnel . TunnelDict ], * , check_local_port : bool = True , debug : bool = False , timeout : int = 60 ) Create a Tunnel instance with a pre-defined list of tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. tunnel_list ( list [ dict ] ) \u2013 List of dictionaries specifying tunnel configurations. Each dictionary must have the keys command , pattern , name , note (optional), and callback (optional). check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. Default True. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. Default False. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. Default 60. add_tunnel add_tunnel ( * , command : str , pattern : re . Pattern | str , name : str , note : str = None , callback : typing . Callable [[ str , str ], None ] = None ) Add a tunnel. Parameters: command ( str ) \u2013 The command to execute for the tunnel. pattern ( re . Pattern | str ) \u2013 A regular expression pattern to match the tunnel URL. name ( str ) \u2013 The name of the tunnel. note ( typing . Optional [ str ] , default: None ) \u2013 A note about the tunnel. callback ( typing . Callable [[ str , str ], None] , default: None ) \u2013 A callback function to be called when when the regex pattern matched. callback(url, note) -> None start start () Start the tunnel and wait for the URLs to be printed. Raises: RuntimeError \u2013 Raise if tunnel is already running stop stop () Stop the tunnel and reset internal state. Raises: RuntimeError \u2013 Raise if tunnel is not running reset reset () Reset internal state. is_port_available staticmethod is_port_available ( port : int ) -> bool Check if the specified port is available. Parameters: port ( int ) \u2013 The port to check. Returns: bool ( bool ) \u2013 True if the port is available, False otherwise. wait_for_condition staticmethod wait_for_condition ( condition : typing . Callable [[], bool ], * , interval : int = 1 , timeout : int | None = 10 ) -> bool Wait for the condition to be true until the specified timeout. Mostly for internal use but can be used for anything else. Parameters: condition ( typing . Callable [[], bool ] ) \u2013 The condition to check. interval ( int , default: 1 ) \u2013 The interval (in seconds) between condition checks. timeout ( int , default: 10 ) \u2013 Maximum time to wait for the condition. None for no timeout. Returns: bool ( bool ) \u2013 True if the condition is met, False if timeout is reached.","title":"tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel","text":"Tunnel class for managing subprocess-based tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. Default True. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. Default False. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. Default 60. propagate ( bool , default: False ) \u2013 Flag to propagate log messages to the root logger, if False will create custom log format to print log. Default False. log_dir ( os . PathLike , default: os . getcwd () ) \u2013 Directory to store log files. Default os.getcwd(). callback ( typing . Callable [[ list [ tuple [ str , str | None]]], None] , default: None ) \u2013 A callback function to be called when Tunnel URL is printed. callback([(url1, note1), (url2, note2), ...]) -> None","title":"Tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel.with_tunnel_list","text":"with_tunnel_list ( port : int , tunnel_list : list [ tunnel . TunnelDict ], * , check_local_port : bool = True , debug : bool = False , timeout : int = 60 ) Create a Tunnel instance with a pre-defined list of tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. tunnel_list ( list [ dict ] ) \u2013 List of dictionaries specifying tunnel configurations. Each dictionary must have the keys command , pattern , name , note (optional), and callback (optional). check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. Default True. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. Default False. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. Default 60.","title":"with_tunnel_list"},{"location":"reference/tunnel/#tunnel.Tunnel.add_tunnel","text":"add_tunnel ( * , command : str , pattern : re . Pattern | str , name : str , note : str = None , callback : typing . Callable [[ str , str ], None ] = None ) Add a tunnel. Parameters: command ( str ) \u2013 The command to execute for the tunnel. pattern ( re . Pattern | str ) \u2013 A regular expression pattern to match the tunnel URL. name ( str ) \u2013 The name of the tunnel. note ( typing . Optional [ str ] , default: None ) \u2013 A note about the tunnel. callback ( typing . Callable [[ str , str ], None] , default: None ) \u2013 A callback function to be called when when the regex pattern matched. callback(url, note) -> None","title":"add_tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel.start","text":"start () Start the tunnel and wait for the URLs to be printed. Raises: RuntimeError \u2013 Raise if tunnel is already running","title":"start"},{"location":"reference/tunnel/#tunnel.Tunnel.stop","text":"stop () Stop the tunnel and reset internal state. Raises: RuntimeError \u2013 Raise if tunnel is not running","title":"stop"},{"location":"reference/tunnel/#tunnel.Tunnel.reset","text":"reset () Reset internal state.","title":"reset"},{"location":"reference/tunnel/#tunnel.Tunnel.is_port_available","text":"is_port_available ( port : int ) -> bool Check if the specified port is available. Parameters: port ( int ) \u2013 The port to check. Returns: bool ( bool ) \u2013 True if the port is available, False otherwise.","title":"is_port_available"},{"location":"reference/tunnel/#tunnel.Tunnel.wait_for_condition","text":"wait_for_condition ( condition : typing . Callable [[], bool ], * , interval : int = 1 , timeout : int | None = 10 ) -> bool Wait for the condition to be true until the specified timeout. Mostly for internal use but can be used for anything else. Parameters: condition ( typing . Callable [[], bool ] ) \u2013 The condition to check. interval ( int , default: 1 ) \u2013 The interval (in seconds) between condition checks. timeout ( int , default: 10 ) \u2013 Maximum time to wait for the condition. None for no timeout. Returns: bool ( bool ) \u2013 True if the condition is met, False if timeout is reached.","title":"wait_for_condition"}]}