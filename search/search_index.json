{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python tunnel This Python package provides a convenient wrapper for running tunnel commands. Documentation Documentation are located here Usage This is not a module, instead, you can just download tunnel.py and import it from tunnel import Tunnel # Setting up the tunnel wrapper = Tunnel(3000) # Tunnel on port 3000 wrapper.add_tunnel( command=\"cloudflared tunnel --url http://localhost:{port}\", # {port} automatically changed to 3000 pattern=r\"[\\w-]+\\.trycloudflare\\.com\", name=\"Cloudflare\" ) # Starting the tunnel wrapper.start() # Stopping the tunnel wrapper.stop() # Using a with block with wrapper: pass # Setting up tunnel with a list tunnel_list = [ { \"command\": \"tunnel_1_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_1\" }, { \"command\": \"tunnel_2_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_2\" } ] wrapper = Tunnel.with_tunnel_list(3000, tunnel_list) wrapper.start() TODO [ ] - Licensed under the terms of the MIT License. See the LICENSE file for details.","title":"README"},{"location":"#python-tunnel","text":"This Python package provides a convenient wrapper for running tunnel commands.","title":"python tunnel"},{"location":"#documentation","text":"Documentation are located here","title":"Documentation"},{"location":"#usage","text":"This is not a module, instead, you can just download tunnel.py and import it from tunnel import Tunnel # Setting up the tunnel wrapper = Tunnel(3000) # Tunnel on port 3000 wrapper.add_tunnel( command=\"cloudflared tunnel --url http://localhost:{port}\", # {port} automatically changed to 3000 pattern=r\"[\\w-]+\\.trycloudflare\\.com\", name=\"Cloudflare\" ) # Starting the tunnel wrapper.start() # Stopping the tunnel wrapper.stop() # Using a with block with wrapper: pass # Setting up tunnel with a list tunnel_list = [ { \"command\": \"tunnel_1_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_1\" }, { \"command\": \"tunnel_2_cmd\", \"pattern\": r\"tunnel_1_pattern\", \"name\": \"tunnel_2\" } ] wrapper = Tunnel.with_tunnel_list(3000, tunnel_list) wrapper.start()","title":"Usage"},{"location":"#todo","text":"[ ] - Licensed under the terms of the MIT License. See the LICENSE file for details.","title":"TODO"},{"location":"reference/SUMMARY/","text":"tunnel","title":"SUMMARY"},{"location":"reference/tunnel/","text":"Tunnel Tunnel class for managing subprocess-based tunnels. __init__ __init__( port: int , *, check_local_port: bool = True, debug: bool = False, timeout: int = 60 ) Tunnel class for managing subprocess-based tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. Default True. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. Default False. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. Default 60. with_tunnel_list classmethod with_tunnel_list( port: int , tunnel_list: list [ tunnel . TunnelDict ], *, check_local_port: bool = True, debug: bool = False, timeout: int = 60 ) Create a Tunnel instance with a pre-defined list of tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. tunnel_list ( list [ dict ] ) \u2013 List of dictionaries specifying tunnel configurations. Each dictionary must have the keys 'command', 'pattern', 'name', and 'note' (optional). check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. Default True. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. Default False. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. Default 60. add_tunnel add_tunnel( *, command: str , pattern: re . Pattern | str , name: str , note: typing . Optional [ str ] = None ) Add a tunnel. Parameters: command ( str ) \u2013 The command to execute for the tunnel. pattern ( re . Pattern | str ) \u2013 A regular expression pattern to match the tunnel URL. name ( str ) \u2013 The name of the tunnel. note ( typing . Optional [ str ] , default: None ) \u2013 A note about the tunnel. start start() Start the tunnel and wait for the URLs to be printed. Raises: RuntimeError \u2013 Raise if tunnel is already running stop stop() Stop the tunnel and reset internal state. Raises: RuntimeError \u2013 Raise if tunnel is not running reset reset() Reset internal state. is_port_available staticmethod is_port_available(port: int ) -> bool Check if the specified port is available. Parameters: port ( int ) \u2013 The port to check. Returns: bool ( bool ) \u2013 True if the port is available, False otherwise. wait_for_condition staticmethod wait_for_condition( condition: typing . Callable [[], bool ], *, interval: int = 1, timeout: int | None = 10 ) -> bool Wait for the condition to be true until the specified timeout. Mostly for internal use but can be used for anything else. Parameters: condition ( typing . Callable [[], bool ] ) \u2013 The condition to check. interval ( int , default: 1 ) \u2013 The interval (in seconds) between condition checks. timeout ( int , default: 10 ) \u2013 Maximum time to wait for the condition. None for no timeout. Returns: bool ( bool ) \u2013 True if the condition is met, False if timeout is reached.","title":"tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel","text":"Tunnel class for managing subprocess-based tunnels.","title":"Tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel.__init__","text":"__init__( port: int , *, check_local_port: bool = True, debug: bool = False, timeout: int = 60 ) Tunnel class for managing subprocess-based tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. Default True. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. Default False. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. Default 60.","title":"__init__"},{"location":"reference/tunnel/#tunnel.Tunnel.with_tunnel_list","text":"with_tunnel_list( port: int , tunnel_list: list [ tunnel . TunnelDict ], *, check_local_port: bool = True, debug: bool = False, timeout: int = 60 ) Create a Tunnel instance with a pre-defined list of tunnels. Parameters: port ( int ) \u2013 The local port on which the tunnels will be created. tunnel_list ( list [ dict ] ) \u2013 List of dictionaries specifying tunnel configurations. Each dictionary must have the keys 'command', 'pattern', 'name', and 'note' (optional). check_local_port ( bool , default: True ) \u2013 Flag to check if the local port is available. Default True. debug ( bool , default: False ) \u2013 Flag to enable debug mode for additional output. Default False. timeout ( int , default: 60 ) \u2013 Maximum time to wait for the tunnels to start. Default 60.","title":"with_tunnel_list"},{"location":"reference/tunnel/#tunnel.Tunnel.add_tunnel","text":"add_tunnel( *, command: str , pattern: re . Pattern | str , name: str , note: typing . Optional [ str ] = None ) Add a tunnel. Parameters: command ( str ) \u2013 The command to execute for the tunnel. pattern ( re . Pattern | str ) \u2013 A regular expression pattern to match the tunnel URL. name ( str ) \u2013 The name of the tunnel. note ( typing . Optional [ str ] , default: None ) \u2013 A note about the tunnel.","title":"add_tunnel"},{"location":"reference/tunnel/#tunnel.Tunnel.start","text":"start() Start the tunnel and wait for the URLs to be printed. Raises: RuntimeError \u2013 Raise if tunnel is already running","title":"start"},{"location":"reference/tunnel/#tunnel.Tunnel.stop","text":"stop() Stop the tunnel and reset internal state. Raises: RuntimeError \u2013 Raise if tunnel is not running","title":"stop"},{"location":"reference/tunnel/#tunnel.Tunnel.reset","text":"reset() Reset internal state.","title":"reset"},{"location":"reference/tunnel/#tunnel.Tunnel.is_port_available","text":"is_port_available(port: int ) -> bool Check if the specified port is available. Parameters: port ( int ) \u2013 The port to check. Returns: bool ( bool ) \u2013 True if the port is available, False otherwise.","title":"is_port_available"},{"location":"reference/tunnel/#tunnel.Tunnel.wait_for_condition","text":"wait_for_condition( condition: typing . Callable [[], bool ], *, interval: int = 1, timeout: int | None = 10 ) -> bool Wait for the condition to be true until the specified timeout. Mostly for internal use but can be used for anything else. Parameters: condition ( typing . Callable [[], bool ] ) \u2013 The condition to check. interval ( int , default: 1 ) \u2013 The interval (in seconds) between condition checks. timeout ( int , default: 10 ) \u2013 Maximum time to wait for the condition. None for no timeout. Returns: bool ( bool ) \u2013 True if the condition is met, False if timeout is reached.","title":"wait_for_condition"}]}